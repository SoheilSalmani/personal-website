---
title: dbt
relatedResources:
  - https://docs.getdbt.com/
tags:
  - Data Engineering
  - dbt
---

1. Create a new GCP project and generate a keyfile to be used by dbt. Test the
   following query in BigQuery.

   ```sql nu
   with customers as (

       select
           id as customer_id,
           first_name,
           last_name

       from `dbt-tutorial`.jaffle_shop.customers

   ),

   orders as (

       select
           id as order_id,
           user_id as customer_id,
           order_date,
           status

       from `dbt-tutorial`.jaffle_shop.orders

   ),

   customer_orders as (

       select
           customer_id,

           min(order_date) as first_order_date,
           max(order_date) as most_recent_order_date,
           count(order_id) as number_of_orders

       from orders

       group by 1

   ),

   final as (

       select
           customers.customer_id,
           customers.first_name,
           customers.last_name,
           customer_orders.first_order_date,
           customer_orders.most_recent_order_date,
           coalesce(customer_orders.number_of_orders, 0) as number_of_orders

       from customers

       left join customer_orders using (customer_id)

   )

   select * from final
   ```

   <Solution>

   Create a service account named `dbt-user` and give it the "BigQuery User"
   role.

   </Solution>

2. In dbt Cloud, create a new dbt repository and name it `dbt-tutorial`. Then
   initialize the starter project, name the dbt project `jaffle_shop`, and run
   it. Finally, make a commit through the IDE.

   <Solution>

   ```yml fp=dbt_project.yml hl=1,6
   name: "jaffle_shop"

   # ...

   models:
     jaffle_shop:
       # ...
   ```

   </Solution>

3. Same but this time using the dbt CLI and GitHub.

   <Solution>

   ```sh
   dbt --version
   dbt init dbt-tutorial
   cd dbt-tutorial
   ```

   ```yml fp=dbt_project.yml hl=1,5,10
   name: "jaffle_shop"

   # ...

   profile: jaffle_shop

   # ...

   models:
     jaffle_shop:
       # ...
   ```

   ```yml fp=~/.dbt/profiles.yml nu
   jaffle_shop:
     target: dev
     outputs:
       dev:
         type: bigquery
         method: service-account
         keyfile: <keyfile-path>
         project: <project-id>
         dataset: dbt_soheil
         threads: 1
         timeout_seconds: 300
         location: US
         priority: interactive
   ```

   ```sh
   dbt debug
   dbt run
   ```

   </Solution>

4. Create a branch named `add-customers-model`. Add the `customers.sql` model,
   and run dbt.

5. How can I see the SQL that dbt is running?

   <Solution>

   To check out the SQL that dbt is running, you can look in:

   - dbt Cloud:
     - Within the run output, click on a model name, and then select "Details"
   - dbt CLI:
     - The `target/compiled/` directory for compiled `select` statements
     - The `target/run/` directory for compiled `create` statements
     - The `logs/dbt.log` file for verbose logging.

   </Solution>

6. How did dbt choose which schema to build my models in?

   <Solution>

   By default, dbt builds models in your target schema. To change your target
   schema:

   - If you're developing in **dbt Cloud**, these are set for each user when you
     first use a development environment.
   - If you're developing with the **dbt CLI**, this is the `schema:` parameter
     in your `profiles.yml` file.

   </Solution>

7. Update the materialization of some models. Then, delete the example models.

   <Solution>

   ```yml fp=dbt_project.yml
   models:
     jaffle_shop:
       +materialized: table
       example:
         +materialized: view
   ```

   ```sh
   dbt run
   ```

   ```sql fp=models/customers.sql nu
   {{
     config(
       materialized='view'
     )
   }}

   with customers as (

       select
           id as customer_id
           ...

   )
   ```

   ```sh
   dbt run
   dbt run --full-refresh # BigQuery
   ```

   </Solution>

8. What other model configurations are there?

   <Solution>

   You can also configure:

   - tags to support easy categorization and graph selection
   - custom schemas to split your models across multiple schemas
   - aliases if your view/table name should differ from the filename
   - snippets of SQL to run at the start or end of a model, known as hooks
   - warehouse-specific configurations for performance (e.g. `sort` and `dist`
     keys on Redshift, `partitions` on BigQuery)

   </Solution>

9. Refactor your code to have three dbt models.

   <Solution>

   ```sql fp=models/stg_orders.sql nu
   select
       id as order_id,
       user_id as customer_id,
       order_date,
       status

   from `dbt-tutorial`.jaffle_shop.orders
   ```

   ```sql fp=models/staging/stg_customers.sql nu
   select
       id as customer_id,
       first_name,
       last_name

   from `dbt-tutorial`.jaffle_shop.customers
   ```

   ```sql fp=models/customers.sql nu hl=3,9
   with customers as (

       select * from {{ ref('stg_customers') }}

   ),

   orders as (

       select * from {{ ref('stg_orders') }}

   ),

   customer_orders as (

       select
           customer_id,

           min(order_date) as first_order_date,
           max(order_date) as most_recent_order_date,
           count(order_id) as number_of_orders

       from orders

       group by 1

   ),

   final as (

       select
           customers.customer_id,
           customers.first_name,
           customers.last_name,
           customer_orders.first_order_date,
           customer_orders.most_recent_order_date,
           coalesce(customer_orders.number_of_orders, 0) as number_of_orders

       from customers

       left join customer_orders using (customer_id)

   )

   select * from final
   ```

   ```yml fp=dbt_project.yml hl=4..5
   models:
     jaffle_shop:
       +materialized: table
       staging:
         +materialized: view
   ```

   </Solution>

10. How to select resources to build?

    <Solution>

    To select resources to build, use the `--select` flag (or `-s` flag):

    ```sh
    dbt run --select +customers --exclude customers
    dbt run -s staging.*
    ```

    </Solution>

11. Write schema tests.

    <Solution>

    ```yml fp=models/schema.yml nu
    version: 2

    models:
      - name: customers
        columns:
          - name: customer_id
            tests:
              - unique
              - not_null

      - name: stg_customers
        columns:
          - name: customer_id
            tests:
              - unique
              - not_null

      - name: stg_orders
        columns:
          - name: order_id
            tests:
              - unique
              - not_null
          - name: status
            tests:
              - accepted_values:
                  values:
                    [
                      "placed",
                      "shipped",
                      "completed",
                      "return_pending",
                      "returned",
                    ]
          - name: customer_id
            tests:
              - not_null
              - relationships:
                  to: ref('stg_customers')
                  field: customer_id
    ```

    ```sh
    dbt test
    ```

    </Solution>

12. What tests are available out of the box in dbt?

    <Solution>

    Out of the box, dbt ships with the following tests:

    - `unique`
    - `not_null`
    - `accepted_values`
    - `relationships` (i.e. referential integrity)

    </Solution>

13. What tests should we add to a project?

    <Solution>

    We recommend that every model has a test on a primary key, that is, a column
    that is `unique` and `not_null`.

    We also recommend that you test any assumptions on your source data. For
    example, if you believe that your payments can only be one of three payment
    methods, you should test that assumption regularly â€” a new payment method
    may introduce logic errors in your SQL.

    In advanced dbt projects, we recommend using sources and running these
    source data-integrity tests against the sources rather than models.

    </Solution>

14. When should we run tests?

    <Solution>

    You should run your tests whenever you are writing new code (to ensure you
    haven't broken any existing models by changing SQL), and whenever you run
    your transformations in production (to ensure that your assumptions about
    your source data are still valid).

    </Solution>

15. Document your models.

    <Solution>

    ```yml fp=models/schema.yml nu hl=5,8,13,16,25,28
    version: 2

    models:
      - name: customers
        description: One record per customer
        columns:
          - name: customer_id
            description: Primary key
            tests:
              - unique
              - not_null
          - name: first_order_date
            description: NULL when a customer has not yet placed an order.

      - name: stg_customers
        description: This model cleans up customer data
        columns:
          - name: customer_id
            description: Primary key
            tests:
              - unique
              - not_null

      - name: stg_orders
        description: This model cleans up order data
        columns:
          - name: order_id
            description: Primary key
            tests:
              - unique
              - not_null
          - name: status
            tests:
              - accepted_values:
                  values:
                    [
                      "placed",
                      "shipped",
                      "completed",
                      "return_pending",
                      "returned",
                    ]
    ```

    ```sh
    dbt docs generate
    dbt docs serve
    ```

    </Solution>

16. How to write long-form explanations in descriptions?

    <Solution>

    1. Split your description over multiple lines, like so:

       ```yaml
       version: 2

       models:
         - name: customers
           description: >
             Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
             eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim
             ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
             aliquip ex ea commodo consequat.
       ```

    2. Use a docs block to write the description in a Markdown file.

       ```md fp=models/customers.md nu
       {% docs customers %}
       This is the `customers` model.
       {% enddocs %}
       ```

       ```yaml fp=schema.yml hl=5
       version: 2

       models:
         - name: customers
           description: "{{ doc('customers') }}"
       ```

    </Solution>
